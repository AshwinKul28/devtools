"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/base32.js";
exports.ids = ["vendor-chunks/base32.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/base32.js/base32.js":
/*!******************************************!*\
  !*** ./node_modules/base32.js/base32.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * Generate a character map.\n * @param {string} alphabet e.g. \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"\n * @param {object} mappings map overrides from key to value\n * @method\n */ var charmap = function(alphabet, mappings) {\n    mappings || (mappings = {});\n    alphabet.split(\"\").forEach(function(c, i) {\n        if (!(c in mappings)) mappings[c] = i;\n    });\n    return mappings;\n};\n/**\n * The RFC 4648 base 32 alphabet and character map.\n * @see {@link https://tools.ietf.org/html/rfc4648}\n */ var rfc4648 = {\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\",\n    charmap: {\n        0: 14,\n        1: 8\n    }\n};\nrfc4648.charmap = charmap(rfc4648.alphabet, rfc4648.charmap);\n/**\n * The Crockford base 32 alphabet and character map.\n * @see {@link http://www.crockford.com/wrmg/base32.html}\n */ var crockford = {\n    alphabet: \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\",\n    charmap: {\n        O: 0,\n        I: 1,\n        L: 1\n    }\n};\ncrockford.charmap = charmap(crockford.alphabet, crockford.charmap);\n/**\n * base32hex\n * @see {@link https://en.wikipedia.org/wiki/Base32#base32hex}\n */ var base32hex = {\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\",\n    charmap: {}\n};\nbase32hex.charmap = charmap(base32hex.alphabet, base32hex.charmap);\n/**\n * Create a new `Decoder` with the given options.\n *\n * @param {object} [options]\n *   @param {string} [type] Supported Base-32 variants are \"rfc4648\" and\n *     \"crockford\".\n *   @param {object} [charmap] Override the character map used in decoding.\n * @constructor\n */ function Decoder(options) {\n    this.buf = [];\n    this.shift = 8;\n    this.carry = 0;\n    if (options) {\n        switch(options.type){\n            case \"rfc4648\":\n                this.charmap = exports.rfc4648.charmap;\n                break;\n            case \"crockford\":\n                this.charmap = exports.crockford.charmap;\n                break;\n            case \"base32hex\":\n                this.charmap = exports.base32hex.charmap;\n                break;\n            default:\n                throw new Error(\"invalid type\");\n        }\n        if (options.charmap) this.charmap = options.charmap;\n    }\n}\n/**\n * The default character map coresponds to RFC4648.\n */ Decoder.prototype.charmap = rfc4648.charmap;\n/**\n * Decode a string, continuing from the previous state.\n *\n * @param {string} str\n * @return {Decoder} this\n */ Decoder.prototype.write = function(str) {\n    var charmap = this.charmap;\n    var buf = this.buf;\n    var shift = this.shift;\n    var carry = this.carry;\n    // decode string\n    str.toUpperCase().split(\"\").forEach(function(char) {\n        // ignore padding\n        if (char == \"=\") return;\n        // lookup symbol\n        var symbol = charmap[char] & 0xff;\n        // 1: 00000 000\n        // 2:          00 00000 0\n        // 3:                    0000 0000\n        // 4:                             0 00000 00\n        // 5:                                       000 00000\n        // 6:                                                00000 000\n        // 7:                                                         00 00000 0\n        shift -= 5;\n        if (shift > 0) {\n            carry |= symbol << shift;\n        } else if (shift < 0) {\n            buf.push(carry | symbol >> -shift);\n            shift += 8;\n            carry = symbol << shift & 0xff;\n        } else {\n            buf.push(carry | symbol);\n            shift = 8;\n            carry = 0;\n        }\n    });\n    // save state\n    this.shift = shift;\n    this.carry = carry;\n    // for chaining\n    return this;\n};\n/**\n * Finish decoding.\n *\n * @param {string} [str] The final string to decode.\n * @return {Array} Decoded byte array.\n */ Decoder.prototype.finalize = function(str) {\n    if (str) {\n        this.write(str);\n    }\n    if (this.shift !== 8 && this.carry !== 0) {\n        this.buf.push(this.carry);\n        this.shift = 8;\n        this.carry = 0;\n    }\n    return this.buf;\n};\n/**\n * Create a new `Encoder` with the given options.\n *\n * @param {object} [options]\n *   @param {string} [type] Supported Base-32 variants are \"rfc4648\" and\n *     \"crockford\".\n *   @param {object} [alphabet] Override the alphabet used in encoding.\n * @constructor\n */ function Encoder(options) {\n    this.buf = \"\";\n    this.shift = 3;\n    this.carry = 0;\n    if (options) {\n        switch(options.type){\n            case \"rfc4648\":\n                this.alphabet = exports.rfc4648.alphabet;\n                break;\n            case \"crockford\":\n                this.alphabet = exports.crockford.alphabet;\n                break;\n            case \"base32hex\":\n                this.alphabet = exports.base32hex.alphabet;\n                break;\n            default:\n                throw new Error(\"invalid type\");\n        }\n        if (options.alphabet) this.alphabet = options.alphabet;\n        else if (options.lc) this.alphabet = this.alphabet.toLowerCase();\n    }\n}\n/**\n * The default alphabet coresponds to RFC4648.\n */ Encoder.prototype.alphabet = rfc4648.alphabet;\n/**\n * Encode a byte array, continuing from the previous state.\n *\n * @param {byte[]} buf The byte array to encode.\n * @return {Encoder} this\n */ Encoder.prototype.write = function(buf) {\n    var shift = this.shift;\n    var carry = this.carry;\n    var symbol;\n    var byte;\n    var i;\n    // encode each byte in buf\n    for(i = 0; i < buf.length; i++){\n        byte = buf[i];\n        // 1: 00000 000\n        // 2:          00 00000 0\n        // 3:                    0000 0000\n        // 4:                             0 00000 00\n        // 5:                                       000 00000\n        // 6:                                                00000 000\n        // 7:                                                         00 00000 0\n        symbol = carry | byte >> shift;\n        this.buf += this.alphabet[symbol & 0x1f];\n        if (shift > 5) {\n            shift -= 5;\n            symbol = byte >> shift;\n            this.buf += this.alphabet[symbol & 0x1f];\n        }\n        shift = 5 - shift;\n        carry = byte << shift;\n        shift = 8 - shift;\n    }\n    // save state\n    this.shift = shift;\n    this.carry = carry;\n    // for chaining\n    return this;\n};\n/**\n * Finish encoding.\n *\n * @param {byte[]} [buf] The final byte array to encode.\n * @return {string} The encoded byte array.\n */ Encoder.prototype.finalize = function(buf) {\n    if (buf) {\n        this.write(buf);\n    }\n    if (this.shift !== 3) {\n        this.buf += this.alphabet[this.carry & 0x1f];\n        this.shift = 3;\n        this.carry = 0;\n    }\n    return this.buf;\n};\n/**\n * Convenience encoder.\n *\n * @param {byte[]} buf The byte array to encode.\n * @param {object} [options] Options to pass to the encoder.\n * @return {string} The encoded string.\n */ exports.encode = function(buf, options) {\n    return new Encoder(options).finalize(buf);\n};\n/**\n * Convenience decoder.\n *\n * @param {string} str The string to decode.\n * @param {object} [options] Options to pass to the decoder.\n * @return {byte[]} The decoded byte array.\n */ exports.decode = function(str, options) {\n    return new Decoder(options).finalize(str);\n};\n// Exports.\nexports.Decoder = Decoder;\nexports.Encoder = Encoder;\nexports.charmap = charmap;\nexports.crockford = crockford;\nexports.rfc4648 = rfc4648;\nexports.base32hex = base32hex;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmFzZTMyLmpzL2Jhc2UzMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViOzs7OztDQUtDLEdBRUQsSUFBSUEsVUFBVSxTQUFVQyxRQUFRLEVBQUVDLFFBQVE7SUFDeENBLFlBQWFBLENBQUFBLFdBQVcsQ0FBQztJQUN6QkQsU0FBU0UsS0FBSyxDQUFDLElBQUlDLE9BQU8sQ0FBQyxTQUFVQyxDQUFDLEVBQUVDLENBQUM7UUFDdkMsSUFBSSxDQUFFRCxDQUFBQSxLQUFLSCxRQUFPLEdBQUlBLFFBQVEsQ0FBQ0csRUFBRSxHQUFHQztJQUN0QztJQUNBLE9BQU9KO0FBQ1Q7QUFFQTs7O0NBR0MsR0FFRCxJQUFJSyxVQUFVO0lBQ1pOLFVBQVU7SUFDVkQsU0FBUztRQUNQLEdBQUc7UUFDSCxHQUFHO0lBQ0w7QUFDRjtBQUVBTyxRQUFRUCxPQUFPLEdBQUdBLFFBQVFPLFFBQVFOLFFBQVEsRUFBRU0sUUFBUVAsT0FBTztBQUUzRDs7O0NBR0MsR0FFRCxJQUFJUSxZQUFZO0lBQ2RQLFVBQVU7SUFDVkQsU0FBUztRQUNQUyxHQUFHO1FBQ0hDLEdBQUc7UUFDSEMsR0FBRztJQUNMO0FBQ0Y7QUFFQUgsVUFBVVIsT0FBTyxHQUFHQSxRQUFRUSxVQUFVUCxRQUFRLEVBQUVPLFVBQVVSLE9BQU87QUFFakU7OztDQUdDLEdBRUQsSUFBSVksWUFBWTtJQUNkWCxVQUFVO0lBQ1ZELFNBQVMsQ0FBQztBQUNaO0FBRUFZLFVBQVVaLE9BQU8sR0FBR0EsUUFBUVksVUFBVVgsUUFBUSxFQUFFVyxVQUFVWixPQUFPO0FBRWpFOzs7Ozs7OztDQVFDLEdBRUQsU0FBU2EsUUFBU0MsT0FBTztJQUN2QixJQUFJLENBQUNDLEdBQUcsR0FBRyxFQUFFO0lBQ2IsSUFBSSxDQUFDQyxLQUFLLEdBQUc7SUFDYixJQUFJLENBQUNDLEtBQUssR0FBRztJQUViLElBQUlILFNBQVM7UUFFWCxPQUFRQSxRQUFRSSxJQUFJO1lBQ2xCLEtBQUs7Z0JBQ0gsSUFBSSxDQUFD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ZUFBZTtJQUNmLE9BQU8sSUFBSTtBQUNiO0FBRUE7Ozs7O0NBS0MsR0FFRFksUUFBUVIsU0FBUyxDQUFDTyxRQUFRLEdBQUcsU0FBVWIsR0FBRztJQUN4QyxJQUFJQSxLQUFLO1FBQ1AsSUFBSSxDQUFDTyxLQUFLLENBQUNQO0lBQ2I7SUFDQSxJQUFJLElBQUksQ0FBQ0MsS0FBSyxLQUFLLEdBQUc7UUFDcEIsSUFBSSxDQUFDRCxHQUFHLElBQUksSUFBSSxDQUFDZCxRQUFRLENBQUMsSUFBSSxDQUFDZ0IsS0FBSyxHQUFHLEtBQUs7UUFDNUMsSUFBSSxDQUFDRCxLQUFLLEdBQUc7UUFDYixJQUFJLENBQUNDLEtBQUssR0FBRztJQUNmO0lBQ0EsT0FBTyxJQUFJLENBQUNGLEdBQUc7QUFDakI7QUFFQTs7Ozs7O0NBTUMsR0FFREksY0FBYyxHQUFHLFNBQVVKLEdBQUcsRUFBRUQsT0FBTztJQUNyQyxPQUFPLElBQUllLFFBQVFmLFNBQVNjLFFBQVEsQ0FBQ2I7QUFDdkM7QUFFQTs7Ozs7O0NBTUMsR0FFREksY0FBYyxHQUFHLFNBQVVJLEdBQUcsRUFBRVQsT0FBTztJQUNyQyxPQUFPLElBQUlELFFBQVFDLFNBQVNjLFFBQVEsQ0FBQ0w7QUFDdkM7QUFFQSxXQUFXO0FBQ1hKLGVBQWUsR0FBR047QUFDbEJNLGVBQWUsR0FBR1U7QUFDbEJWLGVBQWUsR0FBR25CO0FBQ2xCbUIsaUJBQWlCLEdBQUdYO0FBQ3BCVyxlQUFlLEdBQUdaO0FBQ2xCWSxpQkFBaUIsR0FBR1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbmNvZGluZy11dGlsaXRpZXMvLi9ub2RlX21vZHVsZXMvYmFzZTMyLmpzL2Jhc2UzMi5qcz9kYjQxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgY2hhcmFjdGVyIG1hcC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhbHBoYWJldCBlLmcuIFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjdcIlxuICogQHBhcmFtIHtvYmplY3R9IG1hcHBpbmdzIG1hcCBvdmVycmlkZXMgZnJvbSBrZXkgdG8gdmFsdWVcbiAqIEBtZXRob2RcbiAqL1xuXG52YXIgY2hhcm1hcCA9IGZ1bmN0aW9uIChhbHBoYWJldCwgbWFwcGluZ3MpIHtcbiAgbWFwcGluZ3MgfHwgKG1hcHBpbmdzID0ge30pO1xuICBhbHBoYWJldC5zcGxpdChcIlwiKS5mb3JFYWNoKGZ1bmN0aW9uIChjLCBpKSB7XG4gICAgaWYgKCEoYyBpbiBtYXBwaW5ncykpIG1hcHBpbmdzW2NdID0gaTtcbiAgfSk7XG4gIHJldHVybiBtYXBwaW5ncztcbn1cblxuLyoqXG4gKiBUaGUgUkZDIDQ2NDggYmFzZSAzMiBhbHBoYWJldCBhbmQgY2hhcmFjdGVyIG1hcC5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0NjQ4fVxuICovXG5cbnZhciByZmM0NjQ4ID0ge1xuICBhbHBoYWJldDogXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2N1wiLFxuICBjaGFybWFwOiB7XG4gICAgMDogMTQsXG4gICAgMTogOFxuICB9XG59O1xuXG5yZmM0NjQ4LmNoYXJtYXAgPSBjaGFybWFwKHJmYzQ2NDguYWxwaGFiZXQsIHJmYzQ2NDguY2hhcm1hcCk7XG5cbi8qKlxuICogVGhlIENyb2NrZm9yZCBiYXNlIDMyIGFscGhhYmV0IGFuZCBjaGFyYWN0ZXIgbWFwLlxuICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy5jcm9ja2ZvcmQuY29tL3dybWcvYmFzZTMyLmh0bWx9XG4gKi9cblxudmFyIGNyb2NrZm9yZCA9IHtcbiAgYWxwaGFiZXQ6IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISktNTlBRUlNUVldYWVpcIixcbiAgY2hhcm1hcDoge1xuICAgIE86IDAsXG4gICAgSTogMSxcbiAgICBMOiAxXG4gIH1cbn07XG5cbmNyb2NrZm9yZC5jaGFybWFwID0gY2hhcm1hcChjcm9ja2ZvcmQuYWxwaGFiZXQsIGNyb2NrZm9yZC5jaGFybWFwKTtcblxuLyoqXG4gKiBiYXNlMzJoZXhcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2UzMiNiYXNlMzJoZXh9XG4gKi9cblxudmFyIGJhc2UzMmhleCA9IHtcbiAgYWxwaGFiZXQ6IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZcIixcbiAgY2hhcm1hcDoge31cbn07XG5cbmJhc2UzMmhleC5jaGFybWFwID0gY2hhcm1hcChiYXNlMzJoZXguYWxwaGFiZXQsIGJhc2UzMmhleC5jaGFybWFwKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgYERlY29kZXJgIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogICBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIFN1cHBvcnRlZCBCYXNlLTMyIHZhcmlhbnRzIGFyZSBcInJmYzQ2NDhcIiBhbmRcbiAqICAgICBcImNyb2NrZm9yZFwiLlxuICogICBAcGFyYW0ge29iamVjdH0gW2NoYXJtYXBdIE92ZXJyaWRlIHRoZSBjaGFyYWN0ZXIgbWFwIHVzZWQgaW4gZGVjb2RpbmcuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5mdW5jdGlvbiBEZWNvZGVyIChvcHRpb25zKSB7XG4gIHRoaXMuYnVmID0gW107XG4gIHRoaXMuc2hpZnQgPSA4O1xuICB0aGlzLmNhcnJ5ID0gMDtcblxuICBpZiAob3B0aW9ucykge1xuXG4gICAgc3dpdGNoIChvcHRpb25zLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJyZmM0NjQ4XCI6XG4gICAgICAgIHRoaXMuY2hhcm1hcCA9IGV4cG9ydHMucmZjNDY0OC5jaGFybWFwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjcm9ja2ZvcmRcIjpcbiAgICAgICAgdGhpcy5jaGFybWFwID0gZXhwb3J0cy5jcm9ja2ZvcmQuY2hhcm1hcDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYmFzZTMyaGV4XCI6XG4gICAgICAgIHRoaXMuY2hhcm1hcCA9IGV4cG9ydHMuYmFzZTMyaGV4LmNoYXJtYXA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB0eXBlXCIpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmNoYXJtYXApIHRoaXMuY2hhcm1hcCA9IG9wdGlvbnMuY2hhcm1hcDtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGNoYXJhY3RlciBtYXAgY29yZXNwb25kcyB0byBSRkM0NjQ4LlxuICovXG5cbkRlY29kZXIucHJvdG90eXBlLmNoYXJtYXAgPSByZmM0NjQ4LmNoYXJtYXA7XG5cbi8qKlxuICogRGVjb2RlIGEgc3RyaW5nLCBjb250aW51aW5nIGZyb20gdGhlIHByZXZpb3VzIHN0YXRlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge0RlY29kZXJ9IHRoaXNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGNoYXJtYXAgPSB0aGlzLmNoYXJtYXA7XG4gIHZhciBidWYgPSB0aGlzLmJ1ZjtcbiAgdmFyIHNoaWZ0ID0gdGhpcy5zaGlmdDtcbiAgdmFyIGNhcnJ5ID0gdGhpcy5jYXJyeTtcblxuICAvLyBkZWNvZGUgc3RyaW5nXG4gIHN0ci50b1VwcGVyQ2FzZSgpLnNwbGl0KFwiXCIpLmZvckVhY2goZnVuY3Rpb24gKGNoYXIpIHtcblxuICAgIC8vIGlnbm9yZSBwYWRkaW5nXG4gICAgaWYgKGNoYXIgPT0gXCI9XCIpIHJldHVybjtcblxuICAgIC8vIGxvb2t1cCBzeW1ib2xcbiAgICB2YXIgc3ltYm9sID0gY2hhcm1hcFtjaGFyXSAmIDB4ZmY7XG5cbiAgICAvLyAxOiAwMDAwMCAwMDBcbiAgICAvLyAyOiAgICAgICAgICAwMCAwMDAwMCAwXG4gICAgLy8gMzogICAgICAgICAgICAgICAgICAgIDAwMDAgMDAwMFxuICAgIC8vIDQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwIDAwMDAwIDAwXG4gICAgLy8gNTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwMDAgMDAwMDBcbiAgICAvLyA2OiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAwMDAwIDAwMFxuICAgIC8vIDc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDAgMDAwMDAgMFxuXG4gICAgc2hpZnQgLT0gNTtcbiAgICBpZiAoc2hpZnQgPiAwKSB7XG4gICAgICBjYXJyeSB8PSBzeW1ib2wgPDwgc2hpZnQ7XG4gICAgfSBlbHNlIGlmIChzaGlmdCA8IDApIHtcbiAgICAgIGJ1Zi5wdXNoKGNhcnJ5IHwgKHN5bWJvbCA+PiAtc2hpZnQpKTtcbiAgICAgIHNoaWZ0ICs9IDg7XG4gICAgICBjYXJyeSA9IChzeW1ib2wgPDwgc2hpZnQpICYgMHhmZjtcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLnB1c2goY2FycnkgfCBzeW1ib2wpO1xuICAgICAgc2hpZnQgPSA4O1xuICAgICAgY2FycnkgPSAwO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gc2F2ZSBzdGF0ZVxuICB0aGlzLnNoaWZ0ID0gc2hpZnQ7XG4gIHRoaXMuY2FycnkgPSBjYXJyeTtcblxuICAvLyBmb3IgY2hhaW5pbmdcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEZpbmlzaCBkZWNvZGluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cl0gVGhlIGZpbmFsIHN0cmluZyB0byBkZWNvZGUuXG4gKiBAcmV0dXJuIHtBcnJheX0gRGVjb2RlZCBieXRlIGFycmF5LlxuICovXG5cbkRlY29kZXIucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKHN0cikge1xuICBpZiAoc3RyKSB7XG4gICAgdGhpcy53cml0ZShzdHIpO1xuICB9XG4gIGlmICh0aGlzLnNoaWZ0ICE9PSA4ICYmIHRoaXMuY2FycnkgIT09IDApIHtcbiAgICB0aGlzLmJ1Zi5wdXNoKHRoaXMuY2FycnkpO1xuICAgIHRoaXMuc2hpZnQgPSA4O1xuICAgIHRoaXMuY2FycnkgPSAwO1xuICB9XG4gIHJldHVybiB0aGlzLmJ1Zjtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGBFbmNvZGVyYCB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqICAgQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSBTdXBwb3J0ZWQgQmFzZS0zMiB2YXJpYW50cyBhcmUgXCJyZmM0NjQ4XCIgYW5kXG4gKiAgICAgXCJjcm9ja2ZvcmRcIi5cbiAqICAgQHBhcmFtIHtvYmplY3R9IFthbHBoYWJldF0gT3ZlcnJpZGUgdGhlIGFscGhhYmV0IHVzZWQgaW4gZW5jb2RpbmcuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5mdW5jdGlvbiBFbmNvZGVyIChvcHRpb25zKSB7XG4gIHRoaXMuYnVmID0gXCJcIjtcbiAgdGhpcy5zaGlmdCA9IDM7XG4gIHRoaXMuY2FycnkgPSAwO1xuXG4gIGlmIChvcHRpb25zKSB7XG5cbiAgICBzd2l0Y2ggKG9wdGlvbnMudHlwZSkge1xuICAgICAgY2FzZSBcInJmYzQ2NDhcIjpcbiAgICAgICAgdGhpcy5hbHBoYWJldCA9IGV4cG9ydHMucmZjNDY0OC5hbHBoYWJldDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY3JvY2tmb3JkXCI6XG4gICAgICAgIHRoaXMuYWxwaGFiZXQgPSBleHBvcnRzLmNyb2NrZm9yZC5hbHBoYWJldDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYmFzZTMyaGV4XCI6XG4gICAgICAgIHRoaXMuYWxwaGFiZXQgPSBleHBvcnRzLmJhc2UzMmhleC5hbHBoYWJldDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHR5cGVcIik7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYWxwaGFiZXQpIHRoaXMuYWxwaGFiZXQgPSBvcHRpb25zLmFscGhhYmV0O1xuICAgIGVsc2UgaWYgKG9wdGlvbnMubGMpIHRoaXMuYWxwaGFiZXQgPSB0aGlzLmFscGhhYmV0LnRvTG93ZXJDYXNlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBhbHBoYWJldCBjb3Jlc3BvbmRzIHRvIFJGQzQ2NDguXG4gKi9cblxuRW5jb2Rlci5wcm90b3R5cGUuYWxwaGFiZXQgPSByZmM0NjQ4LmFscGhhYmV0O1xuXG4vKipcbiAqIEVuY29kZSBhIGJ5dGUgYXJyYXksIGNvbnRpbnVpbmcgZnJvbSB0aGUgcHJldmlvdXMgc3RhdGUuXG4gKlxuICogQHBhcmFtIHtieXRlW119IGJ1ZiBUaGUgYnl0ZSBhcnJheSB0byBlbmNvZGUuXG4gKiBAcmV0dXJuIHtFbmNvZGVyfSB0aGlzXG4gKi9cblxuRW5jb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHZhciBzaGlmdCA9IHRoaXMuc2hpZnQ7XG4gIHZhciBjYXJyeSA9IHRoaXMuY2Fycnk7XG4gIHZhciBzeW1ib2w7XG4gIHZhciBieXRlO1xuICB2YXIgaTtcblxuICAvLyBlbmNvZGUgZWFjaCBieXRlIGluIGJ1ZlxuICBmb3IgKGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgYnl0ZSA9IGJ1ZltpXTtcblxuICAgIC8vIDE6IDAwMDAwIDAwMFxuICAgIC8vIDI6ICAgICAgICAgIDAwIDAwMDAwIDBcbiAgICAvLyAzOiAgICAgICAgICAgICAgICAgICAgMDAwMCAwMDAwXG4gICAgLy8gNDogICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAgMDAwMDAgMDBcbiAgICAvLyA1OiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAwMCAwMDAwMFxuICAgIC8vIDY6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDAwMDAgMDAwXG4gICAgLy8gNzogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwMCAwMDAwMCAwXG5cbiAgICBzeW1ib2wgPSBjYXJyeSB8IChieXRlID4+IHNoaWZ0KTtcbiAgICB0aGlzLmJ1ZiArPSB0aGlzLmFscGhhYmV0W3N5bWJvbCAmIDB4MWZdO1xuXG4gICAgaWYgKHNoaWZ0ID4gNSkge1xuICAgICAgc2hpZnQgLT0gNTtcbiAgICAgIHN5bWJvbCA9IGJ5dGUgPj4gc2hpZnQ7XG4gICAgICB0aGlzLmJ1ZiArPSB0aGlzLmFscGhhYmV0W3N5bWJvbCAmIDB4MWZdO1xuICAgIH1cblxuICAgIHNoaWZ0ID0gNSAtIHNoaWZ0O1xuICAgIGNhcnJ5ID0gYnl0ZSA8PCBzaGlmdDtcbiAgICBzaGlmdCA9IDggLSBzaGlmdDtcbiAgfVxuXG4gIC8vIHNhdmUgc3RhdGVcbiAgdGhpcy5zaGlmdCA9IHNoaWZ0O1xuICB0aGlzLmNhcnJ5ID0gY2Fycnk7XG5cbiAgLy8gZm9yIGNoYWluaW5nXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBGaW5pc2ggZW5jb2RpbmcuXG4gKlxuICogQHBhcmFtIHtieXRlW119IFtidWZdIFRoZSBmaW5hbCBieXRlIGFycmF5IHRvIGVuY29kZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGVuY29kZWQgYnl0ZSBhcnJheS5cbiAqL1xuXG5FbmNvZGVyLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKGJ1Zikge1xuICAgIHRoaXMud3JpdGUoYnVmKTtcbiAgfVxuICBpZiAodGhpcy5zaGlmdCAhPT0gMykge1xuICAgIHRoaXMuYnVmICs9IHRoaXMuYWxwaGFiZXRbdGhpcy5jYXJyeSAmIDB4MWZdO1xuICAgIHRoaXMuc2hpZnQgPSAzO1xuICAgIHRoaXMuY2FycnkgPSAwO1xuICB9XG4gIHJldHVybiB0aGlzLmJ1Zjtcbn07XG5cbi8qKlxuICogQ29udmVuaWVuY2UgZW5jb2Rlci5cbiAqXG4gKiBAcGFyYW0ge2J5dGVbXX0gYnVmIFRoZSBieXRlIGFycmF5IHRvIGVuY29kZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIHRoZSBlbmNvZGVyLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgZW5jb2RlZCBzdHJpbmcuXG4gKi9cblxuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgRW5jb2RlcihvcHRpb25zKS5maW5hbGl6ZShidWYpO1xufTtcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBkZWNvZGVyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBkZWNvZGUuXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgdG8gcGFzcyB0byB0aGUgZGVjb2Rlci5cbiAqIEByZXR1cm4ge2J5dGVbXX0gVGhlIGRlY29kZWQgYnl0ZSBhcnJheS5cbiAqL1xuXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChzdHIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBEZWNvZGVyKG9wdGlvbnMpLmZpbmFsaXplKHN0cik7XG59O1xuXG4vLyBFeHBvcnRzLlxuZXhwb3J0cy5EZWNvZGVyID0gRGVjb2RlcjtcbmV4cG9ydHMuRW5jb2RlciA9IEVuY29kZXI7XG5leHBvcnRzLmNoYXJtYXAgPSBjaGFybWFwO1xuZXhwb3J0cy5jcm9ja2ZvcmQgPSBjcm9ja2ZvcmQ7XG5leHBvcnRzLnJmYzQ2NDggPSByZmM0NjQ4O1xuZXhwb3J0cy5iYXNlMzJoZXggPSBiYXNlMzJoZXg7XG4iXSwibmFtZXMiOlsiY2hhcm1hcCIsImFscGhhYmV0IiwibWFwcGluZ3MiLCJzcGxpdCIsImZvckVhY2giLCJjIiwiaSIsInJmYzQ2NDgiLCJjcm9ja2ZvcmQiLCJPIiwiSSIsIkwiLCJiYXNlMzJoZXgiLCJEZWNvZGVyIiwib3B0aW9ucyIsImJ1ZiIsInNoaWZ0IiwiY2FycnkiLCJ0eXBlIiwiZXhwb3J0cyIsIkVycm9yIiwicHJvdG90eXBlIiwid3JpdGUiLCJzdHIiLCJ0b1VwcGVyQ2FzZSIsImNoYXIiLCJzeW1ib2wiLCJwdXNoIiwiZmluYWxpemUiLCJFbmNvZGVyIiwibGMiLCJ0b0xvd2VyQ2FzZSIsImJ5dGUiLCJsZW5ndGgiLCJlbmNvZGUiLCJkZWNvZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/base32.js/base32.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/base32.js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base32.js/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n// Module dependencies.\nvar base32 = __webpack_require__(/*! ./base32 */ \"(ssr)/./node_modules/base32.js/base32.js\");\n// Wrap decoder finalize to return a buffer;\nvar finalizeDecode = base32.Decoder.prototype.finalize;\nbase32.Decoder.prototype.finalize = function(buf) {\n    var bytes = finalizeDecode.call(this, buf);\n    return new Buffer(bytes);\n};\n// Export Base32.\nmodule.exports = base32;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmFzZTMyLmpzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsdUJBQXVCO0FBQ3ZCLElBQUlBLFNBQVNDLG1CQUFPQSxDQUFDLDBEQUFVO0FBRy9CLDRDQUE0QztBQUM1QyxJQUFJQyxpQkFBaUJGLE9BQU9HLE9BQU8sQ0FBQ0MsU0FBUyxDQUFDQyxRQUFRO0FBQ3RETCxPQUFPRyxPQUFPLENBQUNDLFNBQVMsQ0FBQ0MsUUFBUSxHQUFHLFNBQVVDLEdBQUc7SUFDL0MsSUFBSUMsUUFBUUwsZUFBZU0sSUFBSSxDQUFDLElBQUksRUFBRUY7SUFDdEMsT0FBTyxJQUFJRyxPQUFPRjtBQUNwQjtBQUdBLGlCQUFpQjtBQUNqQkcsT0FBT0MsT0FBTyxHQUFHWCIsInNvdXJjZXMiOlsid2VicGFjazovL2VuY29kaW5nLXV0aWxpdGllcy8uL25vZGVfbW9kdWxlcy9iYXNlMzIuanMvaW5kZXguanM/YzVhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLy8gTW9kdWxlIGRlcGVuZGVuY2llcy5cbnZhciBiYXNlMzIgPSByZXF1aXJlKFwiLi9iYXNlMzJcIik7XG5cblxuLy8gV3JhcCBkZWNvZGVyIGZpbmFsaXplIHRvIHJldHVybiBhIGJ1ZmZlcjtcbnZhciBmaW5hbGl6ZURlY29kZSA9IGJhc2UzMi5EZWNvZGVyLnByb3RvdHlwZS5maW5hbGl6ZTtcbmJhc2UzMi5EZWNvZGVyLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgdmFyIGJ5dGVzID0gZmluYWxpemVEZWNvZGUuY2FsbCh0aGlzLCBidWYpO1xuICByZXR1cm4gbmV3IEJ1ZmZlcihieXRlcyk7XG59O1xuXG5cbi8vIEV4cG9ydCBCYXNlMzIuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2UzMjtcbiJdLCJuYW1lcyI6WyJiYXNlMzIiLCJyZXF1aXJlIiwiZmluYWxpemVEZWNvZGUiLCJEZWNvZGVyIiwicHJvdG90eXBlIiwiZmluYWxpemUiLCJidWYiLCJieXRlcyIsImNhbGwiLCJCdWZmZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/base32.js/index.js\n");

/***/ })

};
;